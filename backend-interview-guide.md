# 高级后端工程师面试复习指南

## 目录

- [编程语言](#编程语言)
  - [Golang](#golang)
  - [PHP](#php)
- [数据库](#数据库)
  - [MySQL](#mysql)
  - [MongoDB](#mongodb)
- [缓存与NoSQL](#缓存与nosql)
  - [Redis](#redis)
- [网络编程](#网络编程)
- [系统设计](#系统设计)
- [性能优化](#性能优化)
- [安全](#安全)

## 编程语言

### Golang

#### 基础概念
- goroutine和线程的区别
  - goroutine是Go语言运行时调度的轻量级线程
  - goroutine初始栈大小2KB，线程初始栈大小1MB
  - goroutine能够动态伸缩栈大小，最大支持1GB
  - goroutine由Go运行时调度，线程由操作系统调度
  - goroutine切换代价比线程小，没有系统调用开销

- 内存模型
  - Go内存模型定义了并发环境下共享变量的可见性条件
  - happens-before关系保证内存操作的顺序
  - 原子操作和互斥锁提供同步机制
  - 内存重排和编译器优化的影响

#### 并发编程
- channel
  - 通过通信来共享内存，而不是通过共享内存来通信
  - 无缓冲channel vs 有缓冲channel
    - 无缓冲channel：同步通信，发送和接收必须同时准备好
    - 有缓冲channel：异步通信，缓冲区未满时发送不阻塞
  - select机制
    - 多路复用channel操作
    - 随机选择就绪的case执行
    - default分支处理无就绪case的情况

- 并发原语
  - sync.Mutex：互斥锁，保护共享资源
  - sync.RWMutex：读写锁，多读单写场景
  - sync.WaitGroup：等待一组goroutine完成
  - sync.Once：保证函数只执行一次
  - sync.Cond：条件变量，用于goroutine同步

#### 内存管理
- GC机制
  - 三色标记法
    - 白色：未被标记的对象
    - 灰色：已标记但子对象未标记
    - 黑色：已标记且子对象已标记
  - 写屏障
    - 插入写屏障：保护新增引用
    - 删除写屏障：保护删除引用
  - GC触发条件
    - 内存分配达到阈值
    - 定时触发
    - 手动触发

- 内存分配
  - TCMalloc算法
  - 对象分级
    - 微对象（0-16B）
    - 小对象（16B-32KB）
    - 大对象（>32KB）
  - 内存池和缓存机制

#### 常见问题
- defer执行顺序
  - 后进先出（LIFO）原则
  - 参数在defer语句时计算
  - 常见陷阱和最佳实践

- panic和recover机制
  - panic：程序崩溃处理
  - recover：恢复panic状态
  - 使用场景和注意事项

- 接口实现和多态
  - 隐式接口实现
  - 接口组合
  - 空接口和类型断言
  - 接口性能考虑

### PHP

#### 基础特性
- 变量作用域
  - 全局变量和$GLOBALS数组
  - 静态变量和类静态成员
  - 变量引用和生命周期

- 引用传递vs值传递
  - 引用传递的实现机制
  - 写时复制（Copy-on-Write）
  - 性能影响和使用建议

- 魔术方法
  - __construct()和__destruct()
  - __get()、__set()、__isset()、__unset()
  - __call()和__callStatic()
  - __toString()和__clone()

#### 面向对象
- 类与对象
  - 封装、继承、多态
  - 抽象类和接口
  - 后期静态绑定

- 继承与多态
  - 方法重写和重载
  - 访问控制和可见性
  - final关键字

- Trait机制
  - 代码复用的解决方案
  - 优先级和冲突解决
  - 组合vs继承

#### 运行机制
- PHP-FPM
  - 进程管理和池化
  - 请求处理流程
  - 配置优化策略

- OpCache
  - 字节码缓存原理
  - 共享内存机制
  - 缓存失效和更新

- JIT编译
  - 实现原理和优势
  - 使用场景
  - 性能影响

## 数据库

### MySQL

#### 索引
- B+树原理
  - 数据结构特点
  - 查询和维护代价
  - 与其他索引结构对比

- 聚集索引vs非聚集索引
  - InnoDB聚集索引
  - 二级索引
  - 索引覆盖

- 索引优化策略
  - 最左前缀原则
  - 索引下推
  - 索引合并
  - 索引选择性

#### 事务
- ACID特性
  - 原子性：事务的不可分割
  - 一致性：数据库完整性
  - 隔离性：并发事务隔离
  - 持久性：提交后的永久性

- 事务隔离级别
  - 读未提交
  - 读已提交
  - 可重复读
  - 串行化
  - 各级别下的问题和解决

- MVCC机制
  - 实现原理
  - 版本链
  - 快照读和当前读
  - 回滚段

#### 锁机制
- 表锁vs行锁
  - 锁粒度
  - 并发性能
  - 死锁风险

- 死锁预防
  - 死锁检测
  - 超时机制
  - 死锁避免策略

- 乐观锁vs悲观锁
  - 实现方式
  - 使用场景
  - 性能对比

#### 性能优化
- 慢查询优化
  - 执行计划分析
  - 索引优化
  - SQL改写

- 分库分表策略
  - 水平拆分
  - 垂直拆分
  - 分片规则
  - 全局序列

- 读写分离
  - 主从复制
  - 负载均衡
  - 数据一致性

### MongoDB

#### 基础概念
- 文档模型
  - BSON格式
  - 文档结构灵活性
  - 嵌入式文档vs引用

- 集合设计
  - 范式化vs反范式化
  - 文档大小限制
  - 索引策略

- 索引类型
  - 单字段索引
  - 复合索引
  - 多键索引
  - 地理空间索引

#### 高可用
- 副本集
  - 选举机制
  - 同步策略
  - 故障转移

- 分片集群
  - 分片策略
  - 数据分布
  - 路由机制

- 数据一致性
  - 写关注
  - 读关注
  - 因果一致性

## 缓存与NoSQL

### Redis

#### 数据类型
- String
  - 内部编码
  - 使用场景
  - 原子操作

- Hash
  - 存储结构
  - 渐进式rehash
  - 应用场景

- List
  - 链表实现
  - 阻塞操作
  - 消息队列

- Set
  - 去重功能
  - 集合运算
  - 随机获取

- Sorted Set
  - 跳表实现
  - 排序机制
  - 范围查询

#### 持久化
- RDB
  - 快照原理
  - fork机制
  - 优缺点分析

- AOF
  - 日志追加
  - 重写机制
  - 同步策略

- 混合持久化
  - RDB+AOF结合
  - 最佳实践
  - 性能影响

#### 高可用
- 主从复制
  - 复制原理
  - 断点续传
  - 过期处理

- 哨兵模式
  - 监控机制
  - 故障转移
  - 配置管理

- 集群模式
  - 分片算法
  - 槽位分配
  - 扩容缩容

#### 常见问题
- 缓存穿透
  - 原因分析
  - 布隆过滤器
  - 空值缓存

- 缓存击穿
  - 热点key失效
  - 互斥锁
  - 永不过期

- 缓存雪崩
  - 大量key同时失效
  - 过期时间打散
  - 多级缓存

- 数据一致性
  - 更新策略
  - 最终一致性
  - 双写一致性

## 网络编程

### TCP/IP
- 三次握手和四次挥手
  - 状态转换
  - 超时处理
  - 常见问题

- 滑动窗口
  - 流量控制
  - 窗口大小
  - 优化策略

- 拥塞控制
  - 慢启动
  - 拥塞避免
  - 快重传和快恢复

### HTTP
- HTTP/1.1 vs HTTP/2
  - 多路复用
  - 头部压缩
  - 服务器推送
  - 二进制分帧

- HTTPS原理
  - TLS/SSL协议
  - 证书体系
  - 密钥交换
  - 性能优化

- WebSocket
  - 协议特点
  - 握手过程
  - 心跳机制
  - 应用场景

### API设计
- RESTful API
  - 资源定义
  - 状态码
  - 版本控制
  - 安全性

- GraphQL
  - 查询语言
  - 类型系统
  - 解析器
  - N+1问题

- RPC
  - 序列化
  - 服务发现
  - 负载均衡
  - 超时重试

## 系统设计

### 架构模式
- 微服务架构
  - 服务拆分
  - 服务治理
  - 服务编排
  - 服务监控

- DDD领域驱动设计
  - 领域模型
  - 限界上下文
  - 聚合根
  - 领域事件

- CQRS模式
  - 命令和查询分离
  - 事件溯源
  - 最终一致性
  - 性能优化

### 分布式系统
- CAP理论
  - 一致性
  - 可用性
  - 分区容错性
  - 取舍策略

- BASE理论
  - 基本可用
  - 软状态
  - 最终一致性
  - 实践应用

- 分布式事务
  - 2PC/3PC
  - TCC补偿
  - Saga模式
  - 最大努力通知

- 一致性算法
  - Paxos
    - Basic Paxos
    - Multi Paxos
    - 实现难点
  - Raft
    - 领导选举
    - 日志复制
    - 成员变更

### 消息队列
- Kafka
  - 分区机制
  - 消息持久化
  - 消费者组
  - 高可用设计

- RabbitMQ